import argparse
import os
import sys
import pandas as pd
import numpy as np
import re
from Bio import SeqIO
from Bio.Seq import Seq
from Bio.SeqRecord import SeqRecord
parser = argparse.ArgumentParser()

parser.add_argument('-i', '--input', type=str, required=True, help='zf results')
parser.add_argument('-o', '--output', type=str, required=True, help='output file')

args = parser.parse_args()

# define patterns
pattern1 = r'..C..C.{12}H...H.{5}'
pattern2 = r'..C..C.{12}H....H.{5}'

max_covering = 1

flog = open("toto.log", "w")
# output file
f = open(args.output, "w")
f.write("SeqID;Contig;mrna;Status;Pattern;Pattern num;Match num;Tandem num;ZF num;ZF name;Start in prot;End in prot;Length;uniformised ZF string;original SF string;Contig;mrna;dna sequence;dna sequence reading strand;dna sequence length\n")


with open(args.input,'r') as reader :
    dico_gene = {}
    dico_prot = {}
    flag_write = 0
    flag_start = 0
    # name = "none"
    # sequence = "none"
    for line in reader.readlines(): 
        buf = line.split()
        if line[0] == ">"  and buf[0] != ">Results":
            sequence = ""
            name = line.lstrip(">").rstrip()
            infos = name.split(":")
            print("INFOS = ",infos)
            gene_num = infos[2].split(".")[0]
            gene_info = ":".join((infos[0],infos[1],gene_num))
            infos = name.split(".")
            info = infos.pop().rstrip()
            #print("INFOS = ",infos)
            #print("INFO = ["+info+"]")
            if info == "pep" :
                type = "protein"
            elif info == "sp" :
                type = "dna"
            else :
                sys.exit("Unknow type")

            flag_write = 1
            flag_start = 1
        if line[0] == "/"  and flag_start == 1 :
            flag_write = 0    
            seq = Seq(sequence)
            record = SeqRecord(seq, id=name,name=gene_info,description="Generated by genewise ("+type+")")
            #print(record)
            flog.write("debug "+ gene_info+" ==> "+ str(record) +"\n")
            if type == "protein" :
                dico_prot[gene_info] = record
            else :
                dico_gene[gene_info] = record

        if flag_write == 1  :
            #print(line)
            if line[0] != ">" :
                sequence += line.rstrip()
    if dico_gene.keys() != dico_prot.keys() :
        sys.exit("Error in gene and protein dictionnaries")
    for key in dico_gene.keys() :
        print("GENE " + key)
        print()
        print(dico_gene[key])
        print()
        print(dico_prot[key])
        flog.write("========================================================\n")
        flog.write("Processing ["+key+"]\n")
        flog.write("========================================================\n")
        prot_seq = str(dico_prot[key].seq)
        dna_seq = str(dico_gene[key].seq)
        flog.write("DNA = " + dna_seq +"\n")
        flog.write("AA =  " + prot_seq +"\n")
        translated_seq  = str(dico_gene[key].translate().seq)
        print(prot_seq)
        print(translated_seq)
        if prot_seq != translated_seq :
            print("WARNING!Translated dna sequence and protein sequence are different",file=sys.stderr)
            print("AA:           " + prot_seq, file=sys.stderr)
            print("Transl. DNA : " + translated_seq, file=sys.stderr)
            flog.write("\nWARNING!Translated dna sequence and protein sequence are different\n")
            flog.write("AA:           " + prot_seq + "\n")
            flog.write("Transl. DNA : " + translated_seq+ "\n\n")
        else :
            flog.write("Ok. Translated sequence and protein sequence are identical.\n")
        # Recherche des patterns
        # 
        list_of_matches = []
        for pattern in [pattern1,pattern2]:
            print("\nPattern "+pattern+":\n")
            matches_test = re.finditer(pattern, prot_seq)
            for match in matches_test:
                list_of_matches.append([pattern,match])
        sorted_list_of_matches = sorted(list_of_matches, key=lambda element: element[1].span()[0])   # sorrt
        print(sorted_list_of_matches)

        if len(sorted_list_of_matches) > 0 :
            element = sorted_list_of_matches[0]
            match= element[1]
            cur_start = match.span()[0]
            cur_end = match.span()[1]
            flog.write("Check Match 0 : "+str(match.span()[0])+" - "+str(match.span()[1])+"\n")
            superposed_to_remove = []
            for iel in range(1,len(sorted_list_of_matches)) : 
                element = sorted_list_of_matches[iel]
                match= element[1]
                flog.write("Check Match "+str(iel)+" : "+str(match.span()[0])+" - "+str(match.span()[1])+"\n")
                if match.span()[0] <  cur_end :
                    flog.write(" Warning : superposition\n")
                    if match.span()[0] > cur_start:
                        flog.write("Current match "+str(iel-1)+" starts earlier\n")
                        covering  = cur_end -  match.span()[0]
                        flog.write("Covering = " + str(covering) + "\n")
                        if covering > max_covering :
                            flog.write("Remove new match "+str(iel) +"\n")
                            superposed_to_remove.append(sorted_list_of_matches[iel])
                        else :
                            flog.write("Covering is not  > "+str(max_covering) +"\n")
                    if match.span()[0] == cur_start:
                        flog.write("Check on end\n")
                        if match.span()[1] < cur_end:
                            flog.write("Remove current match "+str(iel-1) +"\n")
                            superposed_to_remove.append(sorted_list_of_matches[iel-1])
                        if match.span()[1] > cur_end:
                            flog.write("Remove new match "+str(iel) +"\n")
                            superposed_to_remove.append(sorted_list_of_matches[iel])
                        if match.span()[1] == cur_end: 
                            sys.exit("Unexpected situation (1)")   

                    if match.span()[0] < cur_start:  
                        sys.exit("Unexpected situation (2)")
                cur_start = match.span()[0]
                cur_end = match.span()[1]

            if len(superposed_to_remove) > 0 :
                flog.write("Superposed zinc finger to be removed:\n")
                for to_remove in superposed_to_remove:
                    flog.write(str(to_remove[1].span()) + "\n")
                    sorted_list_of_matches.remove(to_remove)

                flog.write("New zinc finger list\n")
                for element in sorted_list_of_matches :  
                    flog.write("\tMatch "+str(element[1].span()[0])+ " - "+ str(element[1].span()[1])+"\n")
   


        tandem = 0 # will increment for each group of tandem zincfingers
        match_nb = 1 # num of the match in set
        match_tandem_nb = 1 # num of the match in set of tandem zincfingers

        for element in sorted_list_of_matches:
            match  = element[1]
            pattern = element[0]
            if match_nb == 1 :
                current_tandem = match.span()[1]
            if match.span()[0] > current_tandem:
                tandem +=1
                match_tandem_nb = 1
                    # check for superposiition    
            if match_nb > 2 :
                if match.span()[0] < current_tandem:
                    flog.write("\nWARNING: zinc finger superposition. Covering = " + str( current_tandem - match.span()[0] ) + "\n")
                    if current_tandem - match.span()[0] > max_covering :
                        sys.exit("ERROR: zinc finger superposition")

            flog.write("\nMatch "+str(match_nb)+" "+str(match_tandem_nb)+" "+str(tandem)+" "+str(match.span()[0]) + "-"+str(match.span()[1]))
            current_tandem = match.span()[1]
            # get the matching part of the sequence
            zf_length = match.span()[1] - match.span()[0]
            zf = prot_seq[match.span()[0] : match.span()[1]]
            flog.write("("+str(zf_length)+")\n")
            flog.write("Original sequence :    "+str(match.group())+"\n")
            
            modified = False
            if zf_length == 28 :
                modified = True
                zf = prot_seq[match.span()[0] : match.span()[0]+19] + "X" + prot_seq[match.span()[0] + 19 : match.span()[1]]
            flog.write("Modified sequence :    "+zf+"\n")

            if modified == False :
                zf_dna = dna_seq[match.span()[0]*3 : match.span()[1]*3]
            else :
                zf_dna = dna_seq[match.span()[0]*3 : match.span()[0]*3+19*3] + "NNN" + dna_seq[match.span()[0]*3 + 19*3 : match.span()[1]*3]

            dna_record = SeqRecord(Seq(zf_dna), id="ZF",name="gene_info",description="Gbof")
            dna_trad_seq = str(dna_record.translate().seq)
            flog.write("DNA sequence :         "+zf_dna+"\n")
            flog.write("Transl. DNA sequence : "+dna_trad_seq+"\n")
            if dna_trad_seq != zf :
                print("WARNING!Translated dna match and protein match are different",file=sys.stderr)
                print("AA:           "+zf,file=sys.stderr)
                print("Transl. DNA : "+dna_trad_seq,file=sys.stderr)

                flog.write("\nWARNING!Translated dna match and protein match are different\n")
                flog.write("AA:           " + zf + "\n")
                flog.write("Transl. DNA : " + dna_trad_seq+ "\n\n")     

            zfname = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcefghijklmnopqrsruvwxyz"[tandem]+str(match_tandem_nb)
            if modified :
                zfname += "_28"
            else :
                zfname += "_29"    

            status = "Ok"
            buf = key.split(":")
            contig = buf[0]
            mrna = "from genewise"
            raw_seq_extract = zf_dna
            compl = zf_dna
            pattern_nb  = 0
            # f.write("SeqID;Contig;mrna;Status;Pattern;Pattern num;Match num;Tandem num;ZF num;ZF name;Start in prot;End in prot;Length;uniformised ZF string;original SF string;Contig;mrna;dna sequence;dna sequence reading strand;dna sequence length\n")
            # f.write(seq_record.id+";"+seq_genomic[0][0]+";"+seq_genomic[0][1]+";"+status+";"+pattern+";"+str(pattern_nb)+";"+str(match_nb)+";"+str(tandem)+";"+str(match_tandem_nb)+";"+zfname+";"+str(match.span()[0])+";"+str(match.span()[1])+";"+str(zf_length)+";"+zf+";"+str(match.group())+";"+seq_genomic[0][0]+";"+seq_genomic[0][1]+";"+raw_seq_extract+";"+str(compl)+";"+str(len(raw_seq_extract))+"\n")
            f.write(key+";"+contig+";"+mrna+";"+status+";"+pattern+";"+str(pattern_nb)+";"+str(match_nb)+";"+str(tandem)+";"+str(match_tandem_nb)+";"+zfname+";"+str(match.span()[0])+";"+str(match.span()[1])+";"+str(zf_length)+";"+zf+";"+str(match.group())+";"+contig+";"+mrna+";"+zf_dna+";"+str(zf_dna)+";"+str(len(zf_dna))+"\n")
            print("==============================================================")
            match_nb += 1
            match_tandem_nb += 1